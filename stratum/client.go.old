// this is going to be much easier if clientCodec is exported from jsonrpc2.serverRequest
// we will make a pull request for this.
package stratum

import (
    "net/rpc"
    "github.com/trey-jones/rpc-codec/jsonrpc2"
)

type Client struct {
    *rpc.Client
    codec *clientCodec
}

type clientNotification struct {
    Version string           `json:"jsonrpc"`
    Method  string           `json:"method"`
    Params  *json.RawMessage `json:"params"`

    // ID      *json.RawMessage `json:"id"` as far as I know, no ID is sent
}

// identical to jsonrpc2.clientResponse
type clientResponse struct {
    Version string           `json:"jsonrpc"`
    ID      *uint64          `json:"id"`
    Result  *json.RawMessage `json:"result,omitempty"`
    Error   *Error           `json:"error,omitempty"`
}

type clientCodec struct {
	jsonRPC2Codec rpc.ClientCodec
    conn io.ReadWriteCloser
}

func (*c clientCodec) WriteRequest(r *rcp.Request, x interface{}) error {
    return c.jsonRPC2Codec.WriteRequest(r, x)
}


func (c *clientCodec) ReadResponseHeader(r *rpc.Response)error {
    b := make([]byte, 0)
    backup := bytes.NewBuffer(b)
    conn := io.TeeReader(c.conn, backup)
    d, err := json.NewDecoder(conn)
    if err != nil {
        return err
    }

    if err := d.Decode(&notif); err != nil {

    }

    // If return err:
    // - io.EOF will became ErrShutdown or io.ErrUnexpectedEOF
    // - it will be returned as is for all pending calls
    // - client will be shutdown
    // So, return io.EOF as is, return *Error for all other errors.
    if err := c.dec.Decode(&c.resp); err != nil {
        if err == io.EOF {
            return err
        }
        return NewError(errInternal.Code, err.Error())
    }
    if c.resp.ID == nil {
        return c.resp.Error
    }

    c.mutex.Lock()
    r.ServiceMethod = c.pending[*c.resp.ID]
    delete(c.pending, *c.resp.ID)
    c.mutex.Unlock()

    r.Error = ""
    r.Seq = *c.resp.ID
    if c.resp.Error != nil {
        r.Error = c.resp.Error.Error()
    }
    return nil
}

func (c *clientCodec) ReadResponseBody(x interface{})error {
    return c.ReadResponseBody(x)
}

func (c *clientCodec) Close() error {
    return c.jsonRPC2Codec.Close()
}

// public API

func NewClientCodec(conn io.ReadWriteCloser) rpc.ClientCodec {
    return &clientCodec{
        jsonRPC2Codec: jsonrpc2.NewClientCodec(conn),
        conn: conn,
    }
}

func NewClient(conn io.ReadWriteCloser) jsonrpc2.Client {
    return jsonrpc2.NewClientWithCodec(NewClientCodec(conn))
}

// func ReceiveClientNotifications


